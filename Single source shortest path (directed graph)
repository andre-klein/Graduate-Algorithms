Subproblem:
Let D(i,v) = length of shortest path from s to v using at most i edges for 0 <= i <= n-1 and v in V

Base Case:
D(0,s) = 0
D(0,v) = infinity for v != s

Recurrence:
D(i,v) = min(D(i-1,v), min_y(D(i-1,y) + w(y,v))) for 1<=i<=n-1

Pseudocode:

D(0,s) = 0

for all v in V:
	if v = s:
		D(0,s) = 0
	else:
		D(0,v) = infinity

for i = 1 to n-1:
	for all v in V:
		D(i,v) = D(i-1,v)
		//it takes O(n+m) time to look at adjacency list for reverse graph
		//to construct edges out of v
		for all (y,v) in E:
			D(i,v) = min(D(i,v), D(i-1,y) + w(y,v))

return D(n-1,.)

Time Complexity:
O(V*E) or O(n*m)

**************************************************

When there is a negative weight cycle, every row is going to be
different from the next row.
This can be specifically detected if i = n is smaller than
i = n-1. Check if D(n,z) < D(n-1,z) for some z in V
