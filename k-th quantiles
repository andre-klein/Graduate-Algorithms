STEP 1: Let res = {} and frontier = a queue containing our array S

STEP 2: Eject the last element from our frontier and call it G
(i.e. pop our queue from the right side)

STEP 3: Let m = |G|/2. Use the median algorithm (i.e. FastSelect) to identify p = mth smallest element in G.
Where |G| refers to the number of elements in G (or its cardinality/length)

STEP 4: Append the set res with p.

STEP 5: If |res| = k-1, return res (Return means end the entire execution of our algorithm).

STEP 6: If m = 1, go to STEP 2.
Nota Bene: we could also use the condition if |res| > ⌊(k-1)/2⌋ the go to STEP 2
This saves a little bit of time since we don't have to generate the next level in the tree.
However, I though this would make my algorithm more difficult to follow.
Here ⌊x⌋ refers to the floor of x

STEP 7: Otherwise, use m to divide our array into two: G1 with values <= p and G2 with values > p
This step takes O(|G|) time.

STEP 8: Inject G1 then G2 into frontier (i.e. append our queue from the left side)
Go to STEP 2

Correctness:
Assumptions:
1- Our output is a set and therefore can be unsorted
Refer to https://edstem.org/us/courses/32662/discussion/2475185?comment=5683662
2- Our input array S has distinct elements and therefore no two elements are of equal value.
This can also be inferred from the fact that we can divide the Set S into k subsets of the same size.

We are technically implementing a BFS algorithm where the number of subproblems at each level is doubled
but their size is halved (T[n] = 2T[n/2] + O(n))
Note that we terminate our recursion early when we have acquired k-1 elements
which results in O(n*log(k)) runtime instead of O(nlog(n)) time.
In the worst case that k=n, our algorithm has a runtime of O(nlogn).

In STEP 3, there is no need to do floor division since we know that we can divide the set S into K subsets of equal size.
In STEP 4, we are allowed to append res without having to worry about order based on assumption 1.
In STEP 5, we terminate once we have identified all our k-1 elements (i.e. the size of the set res is equal to k-1) which is our desired result
In STEP 6, we ensure that in the edge case where k = n, we don't end up splitting an array of size 1.

Why is this algorithm correct?
We use a queue to ensure that we are applying FastSelect at each level in our tree before we continue to the next level.
If we still haven't met our criterion, |res| = k-1, at the end of our level, we continue to the next level.
Because k is a power of 2, we can safely assume that we can finish traversing the level we're in in the tree.
That is, we don't terminate halfway through a level, resulting in subsets that are of different sizes rather than the same size.

One thing to note is that though this is a BFS algorithm, it's still a D&C approach. Divide & Conquer is a paradigm and not an algorithm.
You can use divide and conquer in anything including BFS, provided you take a problem and break it into smaller subproblems.
I really wish this class would do a better job at explaining that.

Time complexity:
At every level L of our tree, we have 2^L nodes. The root node being at level 0.
Every node entails using the median of medians algorithm (i.e. FastSelect) on an array of size |S|/(2^L) 2^L times.
This means it takes O(n) time to traverse every level in our tree (n*(2^L)/(2^L))
It also taken O(n) time to generate the next level (refer to STEP 7).

How many levels do we have?
At the top level (root), we identify one of our k-1 numbers.
At the next level, we identify two of our k-1 numbers.
At the bottom level we identify k/2 numbers.
It is evident that the height of the tree is log(k)
Therefore, the total runtime is O(n*log(k))
