S={-1, 2, 4, 1, 3, 0, 18, -3}, k = 8
res = {}
frontier = []
G =   
m = 
p = 

This is an application of the median algorithm.

STEP 1: Let res = {} and frontier = a queue containing our array S

STEP 2: Eject the last element from our frontier and call it G
(i.e. pop our queue from the right side)

STEP 3: Let m = |G|/2. Use the median algorithm (i.e. FastSelect) to identify p = mth smallest element.
Where |G| refers to the number of elements in G (or its cardinality/length)

STEP 4: Append the set res with p.

STEP 5: If |res| = k-1, return res.

STEP 6: If m = 1, return to STEP 2.

STEP 7: Otherwise, use m to divide our array into two: G1 with values <= p and G2 with values > p

STEP 8: Inject G1 then G2 into frontier (i.e. append our queue from the left side)
Return to STEP 2

Correctness:
Assumpions:
1- Our output is a set and therefore can be unsorted
Refer to https://edstem.org/us/courses/32662/discussion/2475185?comment=5683662
2- Our input array S has distinct elements and therefore no two elements are of equal value.
This can also be inferred from the fact that we can divide the Set S into k subsets of the same size.

We are technically implementing a BFS algorithm where the number of subproblems at each level is doubled but their size is halved.
In STEP 3, there is no need to do floor division since we know that we can divide the set S into K subsets of equal size.
In STEP 4, we are allowed to append res without having to worry about order based on assumption 1.
In STEP 5, we terminate once we have identified all our k-1 elements (i.e. the size of the set res is equal to k-1) which is our desired result

Why is this algorithm correct? we use a queue to ensure that we are applying FastSelect at each level before we continue to the next level.
If we still haven't met our criterion |res| = k-1 at the end of our level, we continue to the next level.

Time complexity:
At every level L of our tree, we have 2^L nodes. The root node being at level 0.
Every node entails using the median of medians algorithm (i.e. FastSelect) on an array of size |S|/(2^L) 2^L times.
This means it takes O(n) time to traverse every level in our tree (n*(2^L)/(2^L))
How many levels do we have?
At the top level (root), we identify one of our k-1 numbers.
At the next level, we identify two of our k-1 numbers.
At the bottom level we identify k/2 numbers.
It is evident that the height of the tree is log(k)
Therefore, the total runtime is O(n*log(k))
